비지도학습은 정확도 측면에서 많이 떨어지고 전혀 예상치 못한 결과가 나올 확률이 높아서
꼭 필요한 경우가 아니면 거의 사용하지 않는다.
비지도학습 : 데이터 라벨링 작업의 비용이 과다하여 라벨링 안되어있는 데이터들을 사용하기 위해 사용한다.
라벨링이 안되어있는 상태에서 학습을 하는 방법
대표적인 학습법은 클러스터링, 독립성분분석이 있음


클러스터링(군집)
왠만하면 사용 X
데이터에 라벨링이 되어있으면 Classfication
공여지책으로 사용하는게 클러스터링
각각의 데이터들이 뭉치게끔 잘 모아주는 것
계층적 군집과 Point assignment clustering

- k-means Clustering
대표적 클러스터링 알고리즘 중 하나
각 클러스터에 할당된 데이터 포인트의 평균 좌표를 이용해 중심점을 반복해 업데이트하며
클러스터를 형성하는 알고리즘
무작위로 점을 찍어 좌표를 수정해나가는데 각각의 군집의 중심점을 잘표현하는 곳을 찾아냈을 때 군집 형성
군집이 가장 잘 만들었다고 인지하는 방법은 각각의 군집 사이 거리를 확실하게 나눠져있는지
틈 계산 
군집이 확실하게 나눠져있는 걸 알았을 때 각 군집 사이의 틈이 얼마만큼 벌어져있는지

실루엣 : 클러스터링 모델이 얼마나 잘 형성이 되었는가의 평가지표

- 계층적 클러스터링(Hierarchical Clustering)
각각의 집단 사이의 거리를 구하는 법
1. single linkage : 자기가 추정한 그룹 내 서로 가장 가까운 점 사이의 거리
2. complete linkage : 그룹 내 가장 멀리 있는 점 사이 거리
3. average linkage : 그룹 내 모든 점 사이의 평균 거리

도커라이제이션 
컨테이너라이제이션 : 컨테이너를 만드는 기술 (OS, 환경, 실행파일,라이브러리, 앱 등등이 들어감)
Full OS가 들어가는게 아닌, 각 버전만의 차이점만 들어감
환경 때문에 사용, 환경이 안맞으면 실행이 안됨.

(하이퍼바이저) : hyper-v(윈도우), vmware, 버추얼박스, xen project, kvm 등등
가상화 기술 : 한 대의 서버에 여러 개의 가상머신을 돌릴수있게 해주는 역할
외부사람들은 각각의 vm에 접속하여 독립적인 컴퓨터를 사용하는것처럼 받아들이지만
실제로는 물리적인 하나의 서버를 쪼개서 사용하는 개념이다. -> 글로벌하게 키운게 클라우드기술(극적으로 발전된 형태)
하이퍼바이저 -> 가상머신 -> 게스트 OS 서버 위에 서버가 운용되면서 이중으로 용량이 낭비됨
이렇게 하면서 자원을 좀더 효율적으로 사용가능
ex) 웹서버 하나의 용량의 일반적으로 트래픽이 몰리지않는이상 평균적으로 28퍼센트정도밖에 사용안함
한대의 서버에서 가상머신을 만들어 웹서버 여러개를 만드는게 가능하니 훨씬 더 효율적이고 상대적으로 환경적이다.

그리드 컴퓨팅 : 컴퓨터를 많이 사고 네트워크로 다 연결을 시켜 묶어서 큰 하나의 컴퓨터처럼 만드는 것
클라우드 컴퓨팅 : 여기에 가상화 기술이 들어가서 필요한 수만큼의 가상머신 제공 가능

리눅스 기반에서 기본적으로 os에 대한 버전들이 미세하게 틀림
CentOS, Redhat, Oracle linux, Demian 등등
실제로 깔려있는 실행 파일들 = 바이너리, 라이브러리 등등이 전부 다 조금씩 틀림
이런것들을 잘 풀어내기위해서 도커 기술이 시작됨
컨테이너 하나하나는 작고 가벼움.
개발자가 테스트해보고 결과가 괜찮다하면 모델파일이나 개발환경 등을 컨테이너로 만들어 서버에 배포한다.


서버 안에 도커 이미지가 있음(바이너리, 라이브러리 등등이 파일 형태로 있음)

도커는 os의 대부분은 공유하는데 차별점만 만들어서 가져가기 때문에 좀더 가볍게 동작가능

컨테이너 사용 법
개발pc에서 개발환경 만들고 컨테이너 만듦 Dev1 -> 실제 서버로 보내야됨
다이렉트로 컨테이너를 쏘는게아니고, 둘다 준비가 되어있어야됨 중간단계가 하나 더 있음.
그게 컨테이너 레포지토리, 직접 넘기는게 아니고 컨테이너를 레포지토리에 저장,
서버는 레포지토리에서 저장된 컨테이너를 다운받아 운용하는 방식
레포지토리는 로컬, 별도의 클라이언트나 별도의 서비스에서 구현 가능하다.
Azure에도 레포지토리 사용 서비스가 있음.(Azure Container Repository)
깃허브 처럼 도커 허브가 있음. 도커 허브에서 데이터 공유도 가능하다.

리눅스
최고 권한자 : superuser
apt-get : ubuntu 서버 관리 시스템
sudo apt-get update : 업데이트

도커 설치 과정(Ubuntu)
1. set up the repository

$ sudo apt-get install \	여기서 역슬래쉬 \는 명령어를 실행시키지않고 다음줄로 개행해서 이어서 치고싶을때 사용
> apt-transport-https \	웹통신
> ca-certificates \		인증
> curl \			
> gnupg \
lsb-release

sudo usermod -a -G docker $USER : 일반 사용자권한을 가진 유저들한테 도커를 사용할수 있게 하는 명령어
sudo service docker restart : 도커 서비스 재시작

docker run hello-world : 도커를 실행하고 hello world라는걸 실행시켜라
도커 이미지 중에 로컬에서 찾아보니 hello world가 없어서
레포지토리가 연결이 되있으니 레포지토리에서 hello world라는 도커 이미지를 다운받아온거임

리눅스 국룰 : 명령어 뒤에 --help 치면 사용하는 방법을 알려줌.
사용하고 있는 도구를 앞에 치고 그다음에 --version을 치면 버전을 알려줌.

docker pull : 이미지만 가져오기 
docker pull ubuntu:18.04 : ubuntu 이미지, : 뒷부분이 태그 (태그쪽에 버전 안적으면 이미지의 latest 버전 설치됨)
docker images : 로컬에 설치되어있는 도커 이미지 확인
ps : 메모리상 실행되고 있는 프로세스 목록
- PID 프로세스마다 부여되는 고유번호 : 이거 확인하고 이것만 죽일수있음
- TTY = 터미널
docker ps -a : 실행했었던 도커 이미지 목록
docker run --name demo1 -it ubuntu:18.04 /bin/bash : demo1 이름의 ubuntu:18.04 /bin/bash 환경의 도커 이미지 실행
-it : interective terminal : 대화형 터미널, 해당되는 도커에 붙어서 실제로 명령어를 칠수있게끔 해주는 옵션

명령어 처리는 누가 할까? cmd.exe 옛날에는 command.com이었음
cmd안에서 cmd로 또 들어가서 명령어 처리를 할 수있음.

docker run -it -d --name demo2 ubuntu:18.04 : -d = Daemon의 약자, demo2라는 이름의 이미지를 계속 실행해놔줘
docker exec -it demo2 /bin/bash : 실행중인 데몬 demo2를 배쉬셸 커맨드창으로 열어줘

윈도우에서 계속 돌아가는 프로그램들을 서비스라고 함
리눅스나 유닉스에서는 데몬(Daemon)이라고 함.

서비스 생성 할 때 필요한거 : 웹서버 ex)ubuntu 20.04에다가 웹서버 설치, DB는 22.04에서 MySQL을 사용하겠다
하면 이런것들을 도커 이미지를 만들어놓는다.
실제로 사용할 때는 웹서버 이미지를 도커에서 실행시키고, DB 이미지도 따로따로 만들어서
웹서버 이미지에서 DB서비스에 붙어서 사용하면됨.
서비스가많으면 컨테이너는 늘어날수밖에 없음.
도커 이미지와 도커 컨테이너를 관리하는게 일인데 이 관리를 자동으로 하는 프로그램이 쿠버네티스 

docker logs '이미지명' : 로그 확인(도커 이미지에서 어떤 문제가 있는지 추적확인가능)
서비스에 어떤 문제(시스템이상, 시스템 침입자, 예상치못한동작) 발견시 로그확인을 통해 해결책 제시가능
-f : 지속적으로 로그확인(팔로우 모드, 와치 모드라고도 불림)

docker run --name demo3 -d busybox sh -c "while true;do $(echo date);sleep 1;done"
: 1초에 한번씩 날짜값을 찍는다.
busybox라는 이미지 다운하고 "while~do~done" 사이 내용 반복하는 쉘 명령 부여 -> 탈출코드를 넣지 않으면 무한반복
do 뒤의 실행코드 실행하고 sleep 1 = 1초 간 쉬어라

docker stop 컨테이너명 : 도커 이미지 실행중지

우분투 이미지를 가지고 (18.04) 메모리상에 데모1이라는 걸 만들었어
이걸 실행시키면 up해서 활성화 상태로 됨
-d 옵션을 안주거나 stop을 하면 메모리 상에 정지상태로 남아있음
다시 시작을 시키면 실행이 됨
실행을 할 필요가 없는 이미지는 지워야될 필요가 있음

docker rm 컨테이너명 : 컨테이너 지우기

메모리상에 있는 컨테이너를 지웠고

docker images : 현재 다운로드되어있는 이미지 목록 확인

docker rmi 이미지명 : 이미지 지우기(컨테이너 전부 지운 후 가능)
가급적이면 태그(버전)도 입력해서 지워줘야함


도커 파일이 나중에 점점 커지면 감당이안됨
도커 이미지 파일이 하나가 있으면 이 이미지 파일이 도커베이스이미지가 됨
뭐 깔고깔고 하면서 컨테이너를 하나 만들고 또 뭐 하면서 뭘 만들었음
도커 이미지는 차곡차곡 쌓여져있음
서버에 도커 이미지가 있으면 서버에 있는 도커 이미지를 제외한 나머지 내가 만들었던 컨테이너만 서버에 배포가 됨
이미지, 컨테이너별로 고유번호를 비교하면서 서버에 중복되는 대상을 제외한 나머지 배포대상을 배포하게된다.

vi filename 형태로 vi 에디터를 통해 파일을 만들수 있음
